/*
 * The Blue Alliance API v3
 *
 * # Overview    Information and statistics about FIRST Robotics Competition teams and events.   # Authentication   All endpoints require an Auth Key to be passed in the header `X-TBA-Auth-Key`. If you do not have an auth key yet, you can obtain one from your [Account Page](/account).
 *
 * The version of the OpenAPI document: 3.9.9
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`get_district_awards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictAwardsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_district_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictEventsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_district_events_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictEventsKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_district_events_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictEventsSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_district_rankings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictRankingsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_district_teams`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictTeamsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_district_teams_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictTeamsKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_district_teams_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictTeamsSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_teams`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventTeamsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_teams_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventTeamsKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_teams_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventTeamsSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_teams_statuses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventTeamsStatusesError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_events_by_year`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventsByYearError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_events_by_year_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventsByYearKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_events_by_year_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventsByYearSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_insights_leaderboards_year`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInsightsLeaderboardsYearError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_insights_notables_year`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInsightsNotablesYearError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_events_statuses_by_year`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventsStatusesByYearError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_teams`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_teams_by_year`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamsByYearError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_teams_by_year_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamsByYearKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_teams_by_year_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamsByYearSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_teams_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamsKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_teams_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamsSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}


/// Gets a list of awards in the given district.
pub async fn get_district_awards(configuration: &configuration::Configuration, district_key: &str, if_none_match: Option<&str>) -> Result<Vec<models::Award>, Error<GetDistrictAwardsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/district/{district_key}/awards", configuration.base_path, district_key=crate::apis::urlencode(p_district_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictAwardsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of events in the given district.
pub async fn get_district_events(configuration: &configuration::Configuration, district_key: &str, if_none_match: Option<&str>) -> Result<Vec<models::Event>, Error<GetDistrictEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/district/{district_key}/events", configuration.base_path, district_key=crate::apis::urlencode(p_district_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of event keys for events in the given district.
pub async fn get_district_events_keys(configuration: &configuration::Configuration, district_key: &str, if_none_match: Option<&str>) -> Result<Vec<String>, Error<GetDistrictEventsKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/district/{district_key}/events/keys", configuration.base_path, district_key=crate::apis::urlencode(p_district_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictEventsKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a short-form list of events in the given district.
pub async fn get_district_events_simple(configuration: &configuration::Configuration, district_key: &str, if_none_match: Option<&str>) -> Result<Vec<models::EventSimple>, Error<GetDistrictEventsSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/district/{district_key}/events/simple", configuration.base_path, district_key=crate::apis::urlencode(p_district_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictEventsSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of team district rankings for the given district.
pub async fn get_district_rankings(configuration: &configuration::Configuration, district_key: &str, if_none_match: Option<&str>) -> Result<Vec<models::DistrictRanking>, Error<GetDistrictRankingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/district/{district_key}/rankings", configuration.base_path, district_key=crate::apis::urlencode(p_district_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictRankingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of `Team` objects that competed in events in the given district.
pub async fn get_district_teams(configuration: &configuration::Configuration, district_key: &str, if_none_match: Option<&str>) -> Result<Vec<models::Team>, Error<GetDistrictTeamsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/district/{district_key}/teams", configuration.base_path, district_key=crate::apis::urlencode(p_district_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictTeamsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of `Team` objects that competed in events in the given district.
pub async fn get_district_teams_keys(configuration: &configuration::Configuration, district_key: &str, if_none_match: Option<&str>) -> Result<Vec<String>, Error<GetDistrictTeamsKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/district/{district_key}/teams/keys", configuration.base_path, district_key=crate::apis::urlencode(p_district_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictTeamsKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a short-form list of `Team` objects that competed in events in the given district.
pub async fn get_district_teams_simple(configuration: &configuration::Configuration, district_key: &str, if_none_match: Option<&str>) -> Result<Vec<models::TeamSimple>, Error<GetDistrictTeamsSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/district/{district_key}/teams/simple", configuration.base_path, district_key=crate::apis::urlencode(p_district_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictTeamsSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of `Team` objects that competed in the given event.
pub async fn get_event_teams(configuration: &configuration::Configuration, event_key: &str, if_none_match: Option<&str>) -> Result<Vec<models::Team>, Error<GetEventTeamsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/event/{event_key}/teams", configuration.base_path, event_key=crate::apis::urlencode(p_event_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventTeamsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of `Team` keys that competed in the given event.
pub async fn get_event_teams_keys(configuration: &configuration::Configuration, event_key: &str, if_none_match: Option<&str>) -> Result<Vec<String>, Error<GetEventTeamsKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/event/{event_key}/teams/keys", configuration.base_path, event_key=crate::apis::urlencode(p_event_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventTeamsKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a short-form list of `Team` objects that competed in the given event.
pub async fn get_event_teams_simple(configuration: &configuration::Configuration, event_key: &str, if_none_match: Option<&str>) -> Result<Vec<models::TeamSimple>, Error<GetEventTeamsSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/event/{event_key}/teams/simple", configuration.base_path, event_key=crate::apis::urlencode(p_event_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventTeamsSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a key-value list of the event statuses for teams competing at the given event.
pub async fn get_event_teams_statuses(configuration: &configuration::Configuration, event_key: &str, if_none_match: Option<&str>) -> Result<std::collections::HashMap<String, models::GetTeamEventsStatusesByYear200ResponseValue>, Error<GetEventTeamsStatusesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/event/{event_key}/teams/statuses", configuration.base_path, event_key=crate::apis::urlencode(p_event_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventTeamsStatusesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of events in the given year.
pub async fn get_events_by_year(configuration: &configuration::Configuration, year: i32, if_none_match: Option<&str>) -> Result<Vec<models::Event>, Error<GetEventsByYearError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_year = year;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/events/{year}", configuration.base_path, year=p_year);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventsByYearError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of event keys in the given year.
pub async fn get_events_by_year_keys(configuration: &configuration::Configuration, year: i32, if_none_match: Option<&str>) -> Result<Vec<String>, Error<GetEventsByYearKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_year = year;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/events/{year}/keys", configuration.base_path, year=p_year);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventsByYearKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a short-form list of events in the given year.
pub async fn get_events_by_year_simple(configuration: &configuration::Configuration, year: i32, if_none_match: Option<&str>) -> Result<Vec<models::EventSimple>, Error<GetEventsByYearSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_year = year;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/events/{year}/simple", configuration.base_path, year=p_year);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventsByYearSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of `LeaderboardInsight` objects from a specific year. Use year=0 for overall.
pub async fn get_insights_leaderboards_year(configuration: &configuration::Configuration, year: i32, if_none_match: Option<&str>) -> Result<Vec<models::LeaderboardInsight>, Error<GetInsightsLeaderboardsYearError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_year = year;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/insights/leaderboards/{year}", configuration.base_path, year=p_year);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInsightsLeaderboardsYearError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of `NotablesInsight` objects from a specific year. Use year=0 for overall.
pub async fn get_insights_notables_year(configuration: &configuration::Configuration, year: i32, if_none_match: Option<&str>) -> Result<Vec<models::NotablesInsight>, Error<GetInsightsNotablesYearError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_year = year;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/insights/notables/{year}", configuration.base_path, year=p_year);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInsightsNotablesYearError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a key-value list of the event statuses for events this team has competed at in the given year.
pub async fn get_team_events_statuses_by_year(configuration: &configuration::Configuration, team_key: &str, year: i32, if_none_match: Option<&str>) -> Result<std::collections::HashMap<String, models::GetTeamEventsStatusesByYear200ResponseValue>, Error<GetTeamEventsStatusesByYearError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;
    let p_year = year;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/team/{team_key}/events/{year}/statuses", configuration.base_path, team_key=crate::apis::urlencode(p_team_key), year=p_year);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventsStatusesByYearError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of `Team` objects, paginated in groups of 500.
pub async fn get_teams(configuration: &configuration::Configuration, page_num: i32, if_none_match: Option<&str>) -> Result<Vec<models::Team>, Error<GetTeamsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_num = page_num;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/teams/{page_num}", configuration.base_path, page_num=p_page_num);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of `Team` objects that competed in the given year, paginated in groups of 500.
pub async fn get_teams_by_year(configuration: &configuration::Configuration, year: i32, page_num: i32, if_none_match: Option<&str>) -> Result<Vec<models::Team>, Error<GetTeamsByYearError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_year = year;
    let p_page_num = page_num;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/teams/{year}/{page_num}", configuration.base_path, year=p_year, page_num=p_page_num);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamsByYearError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list Team Keys that competed in the given year, paginated in groups of 500.
pub async fn get_teams_by_year_keys(configuration: &configuration::Configuration, year: i32, page_num: i32, if_none_match: Option<&str>) -> Result<Vec<String>, Error<GetTeamsByYearKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_year = year;
    let p_page_num = page_num;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/teams/{year}/{page_num}/keys", configuration.base_path, year=p_year, page_num=p_page_num);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamsByYearKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of short form `Team_Simple` objects that competed in the given year, paginated in groups of 500.
pub async fn get_teams_by_year_simple(configuration: &configuration::Configuration, year: i32, page_num: i32, if_none_match: Option<&str>) -> Result<Vec<models::TeamSimple>, Error<GetTeamsByYearSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_year = year;
    let p_page_num = page_num;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/teams/{year}/{page_num}/simple", configuration.base_path, year=p_year, page_num=p_page_num);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamsByYearSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of Team keys, paginated in groups of 500. (Note, each page will not have 500 teams, but will include the teams within that range of 500.)
pub async fn get_teams_keys(configuration: &configuration::Configuration, page_num: i32, if_none_match: Option<&str>) -> Result<Vec<String>, Error<GetTeamsKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_num = page_num;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/teams/{page_num}/keys", configuration.base_path, page_num=p_page_num);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamsKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a list of short form `Team_Simple` objects, paginated in groups of 500.
pub async fn get_teams_simple(configuration: &configuration::Configuration, page_num: i32, if_none_match: Option<&str>) -> Result<Vec<models::TeamSimple>, Error<GetTeamsSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_num = page_num;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/teams/{page_num}/simple", configuration.base_path, page_num=p_page_num);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamsSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

